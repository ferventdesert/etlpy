
# 过滤和排序器

## 过滤器和where

过滤器会保留所有满足条件的行，不满足条件的将会被过滤。

> 类似地,rm算子(这是转换器)可以过滤掉符合条件的列。

过滤器中，where最为常见，方法与map类似，例如:

`task().p.range(10).where(lambda x:x>5)`

等价于:

`task().p.range(10).where('_>5')`  #value值即为p列对应的值

如果你希望对结果求反（不满足条件的反而留下），则可以使用revert参数，上面的代码也等价于:

`p.range(10).where('_<=4',revert=True)`

若想针对整个数据，而非某一特定列，则可以:

`...let('').where('p>5 && q<3')`  #data宏表示整个字典。

> 宏参数的使用方法和map一致。

## 过滤空对象和字符串

notnull用于过滤空元素和空字符串。

match用于判断当前列的字符串是否匹配。默认为str匹配模式。如果需要正则表达式，则可以:

`...match(regex='\d+')`

## 过滤部分元素

> notin

notin可以过滤那些**不在目标数组**里的元素，传入的参数可以为数组或元组。

`notin([1,2,3])`

notin还能接受字符串参数，使用范围表达式:

`notin('1:100')`



## 排序器

ascend, descend用于排序，值得注意的是，排序器会破坏流的连续性（必须所有数据全部获得后才能排序，因此会有性能问题）。

使用方法和map，where完全一致。

示例代码很简单:

`task().p.range(10).descend(lambda x:len(x))`

或:

`task().p.range(10).descend(len)`


## 一些有趣的讨论

其实可以做到下面的语法：

`t=task().p.range[2:10:2].notin[2:10]`

但为什么不这么用呢？ 因为range是函数而非属性。这样做，就无法区分range到底是算子还是某个列的列名。为了统一性，还是放弃了这样的写法