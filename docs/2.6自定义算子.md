# 自定义算子

一般情况下，用map和where就能满足绝大多数需求，如果某个算子对业务非常有用，则可以自定义算子。


## 新的生成器

从Generator继承，下面是创建一个从p到q的区间数的生成器

```
class MRange(Generator):
    def __init__(self):
        super(MRange, self).__init__()
        self.p= 1  #任何算子都会有个默认参数p
        self.q= 10   #设置默认值
    def generate(self,data,column):  #要重载该函数
        # data参数用于传递当前生成器所在的数据，常用于cross模式，此处可以无视   
        for i in range(p,q):
            yield {column:i}
```
调用时：

`tasK().p.mrange(1,q=20)`


## 新的转换器

从Transformer继承, 写法类似生成器。

根据转换器类型的不同，要重载的函数也不同：

| 类型 |  重载函数 | 构造函数中的参数  |
|  --  |  --     |   --  |
| col  |`def transform(self,data):` | `self.one_input= True` |
| data | `def transform(self, data, col,ncol):`|`self.one_input= False`|
| stream| ` def m_process(self,data,column):`  | `self._m_process=False`| 

## 新的过滤器

从Filter继承, 写法类似生成器。

不论过滤器是哪种类型，都需重载`def filter(self,data)函数`，区别如下

| 类型 |  filter函数中data的意义 | 构造函数中的参数  |
|  --  |  --     |   --  |
| col  | 对目标列过滤   | `self.one_input= True` |
| data | 对数据字典过滤 | `self.one_input= False`|

> 有没有对流做过滤的过滤器呢？暂时没想到

