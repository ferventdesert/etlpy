# 生成器

生成器用于生成数据，流的开头一定是个生成器。如果生成器插在流的中间，就需要与已有的数据流做融合。控制融合的方式是默认的mode参数：

 - cross(*) :  笛卡尔积
 - append(+):  纵向拼接 (默认)
 - merge(|) :  横向拼接
 - mix (mix):  类似ABABAB，依次交错

下面介绍需要集几种常见的生成器：

## create

### 不指定目标列

参数需要为字典数组或字典生成器，例如:
```
task().create(('a':i for i in range(10)))
{'a':1}
{'a':2}
{'a':3}
...
```
参数也可以为pandas的DataFrame,生成对应的字典

### 指定目标列

若指定目标列，参数为数组或生成器，元素可以为任意类型，上面的代码等价于:
`task().a.create(range(10))`

读取文件，并放置于l列中：
`task().l.create(open('file').readlines())`

参数还可以为数字，为生成空字典的个数：

`task().create(5).p.set(10)`

- 输出10个字典，值皆为 {'p':10}


## range

range用于创建区间数，其参数可以有三种形式：

- 元组或列表(元素数量1到3个),如 range((1,10,2))
- 字符串如'1:10', '10',  '1:10:1'， 上面的代码也等价于: `task().a.range('1:10:2')`
- 单个参数，如range(10)
为何要支持字符串形式呢？ 因为最大值或间隔可能来自其他列：

`task().create().p.create([20]).a.range('1:[p]',mode='*')`

上面的代码为：先创建列p，值为20，再在a列上创建区间数，范围从1到20(p列的值)， 组合模式为* (cross).

> 为何range((1,10))不直接写成range(1,10)? 这样岂不是更符合python的规范？原因是range还有可选参数，如果range定义成：

`def range(start=0,end=1,interval=2,mode='*')`
是无法判断range(10)中的10到底是start还是end的。

