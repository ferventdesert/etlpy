

# 核心概念

使用etlpy，先介绍以下核心概念：

## 数据流(generator)

etlpy特别适合批量处理数据，我们称为数据流，典型的数据流如：

- 数组(数组元素可能是字典或对象)，
- 一行行的文本
- Excel，pandas的DataFrame表格
- 1000个web请求

它们共同的特征是每个元素都很相似，能通过迭代器访问。为了简化讨论，我们处理的就是字典的迭代器。想象一个工作流，它能不断地生成和加工字典，最后将字典输出。

# Core Concepts

Before detailed introductions, we will list core concepts as follows:

## generator



## 属性(property)

一个字典如 `{'a':22,'b':33}`，那么a,b就是字典的键，如果有多个字典，都有a,b两个属性，就能形成表格，a,b就是列了，因此`属性`和`列`，可认为是一个概念。

真实的数据处理，一般都会对某个特定属性做连续操作。当let和其他算子指定了某些列后（可以设置多个），etlpy就会记住这个列名，之后所有的操作都针对这些列，直到重新设定了列，被操作的列称为目标列，这样可以简化代码.

## 算子(tool)

算子(op)可以对字典做修改，所有的算子分为四种类型：

- 生成器（GE）:如生成100个字典，键为p，值为‘1’到‘100’
- 转换器（TF）:如将'地址'列中的数字提取到'电话'列中
- 过滤器（FT）:如过滤所有某一列的值为空的的字典
- 执行器（GE）:如将所有的字典存储到MongoDB中。
- 排序器 (ST):如将数据流按a列进行降序排列


算子可以类比于加法和乘法等基本操作。etlpy提供了简单方便的文件读写，web访问等算子，你也可以方便地扩展其他工具来增强功能。

绝大多数算子都包含一个最常用参数，它作用在目标列上，个别算子包含一些可选参数。例如:

```
task().create(datas).a.split(',')   #split的参数就是分割字符，作用在a列
```

参数也可以从其他列读取，上面的代码等价于（具体参考`表达式章节`）：
```
task().create(datas).p.set(',').a.split('[p]')   #等价于上面的值，方括号表达式指代从其他列读取
```
> 算子的设计，尽量追求功能正交化，只实现一个功能，一般算子作用于目标列，参数为默认参数(一部分算子会作用在整个流或者数据上)。


## 任务(task)

所有的任务都以task()来定义，通过组合不同的算子，就能定义完整的task.

通常来说，task都以生成器开头:
```
generator= task('task_name').let('p').create(range(1,20))

for r in t:
    print r

# 等价于:
def generator():
    for i in range(1,20):
        yield {'p':i}
for r in generator():
    print r
 

```
task()函数的参数即该任务的名称,每个任务都需要独一无二的名称，默认为'task'

任务可以理解为函数，可以定义多个任务，父任务可调用子任务。任务也可以调用自身。任务能够被切分，或者保存为json等格式，在网络上传输。

> 之后的示例代码为了简化，可能会省略`task()`开头。

创建task并不会使其执行，它是惰性的。etlpy提供了非常简洁明了的调用方法：

先创建一个任务：`t=task().... # 省略之后的算子`

可以用迭代器，依次访问生成的每个元素：
```
for item in t:
    print t
```

可以直接调用，参数为获取该流的前n个元素，生成字典数组：

`item_list= t(100) `

可以将task导出为json,yaml，同样也能通过json导入:

```
js= task.to_json()
t2=task().load_json(js)
```  

task还可以通过字符串构建，例如:

`t=task().eval('p.range(1,10).format('{_}{_}')')`

多个task可以直接相加:

`t1+=t2`等价于`t1.subge(t2,mode='+')` 即把任务直接拼接起来。

也可以相乘，等价于元素各自做笛卡尔积：`t1*=t2`

也可以求或，等价于两边的数据表横向拼接: `t1|=t2`

## 参数(param)

对算子可能需要传参，若要传的参数较多，会影响可读性，若很多算子都使用相似的参数，那么就更难控制了：

`t=task().get(url='123',cookie='xxx')...get(url='234',cookie='xxx',data=None)`

因此，考虑将传给算子的参数重新包装，作为字典，那么参数传递就变得很容易了：
```
p= Param(url='123',cookie='xxx')
`t=task().get(p)...get(p)`
```

param是具有树结构的字典，key为参数名，值为str/int/lambda,也可以是另一个param。 当param被求值时(p.eval())，它才会递归地计算其中所有的值，最终输出一个POCO类型的字典。

目前etlpy提供了几种默认的param类型，足以满足大部分需要： 从数组中随机选择值（可用于代理随机分配），或lambda表达式，或从目前的数据流里动态求值（使用`[]`表达式）。

param最有趣的地方在于，你可以为param来merge新的参数，生成新的param。如下图所示，b比a多了cookie。这样就能适应复杂多变的为算子传递参数的需求。

TODO: 需要画图

### 工程(project)

一个工程维护了多个任务，这些任务互相可能有依赖。工程包含了默认的环境(env)，包含了所有的task和param。

工程是任务离线保存的最小单元，它也能被保存为json,yaml等用于网络传输等用途，并完整地序列化出等价的project。

使用`from etlpy import *` ，就会创建默认的工程。 



